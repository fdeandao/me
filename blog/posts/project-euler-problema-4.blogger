
Ahora que me hice un tiempo encare el cuarto ejercicio, facil, pero me costo sacarme de la cabeza tratar de hacer todo en lisp con recursion y usar el macro loop (que por cierto es el mas poderozo que he visto en cualquier lenguaje).<br/><br/>algunas cosas para observar:<br/><br/>no se si soy yo, pero usar progn y setq en lisp no me convence, siempre pense al principio en hacer todo recursivo y con let, pero parece que se complica a veces (no conozco una forma de evitar los lets nesteados, debe haber una forma pero no la conozco).<br/><br/>en cuanto a erlang no me gusta la diferencia de and andalso y or y orelse, pero parece que esta ahi por razones historicas, el pattern matching es adictivo, no me gusta que no pueda poner ; en el ultimo guard de un case.<br/><br/>hasta ahora vengo resolviendo el problema primero en python, despues en erlang y despues en lisp, por ahi eso condiciona la forma en la que lo resuelvo, pero siempre trato de usar la solucion que mas se adapta al lenguaje.<br/><br/>aca va el codigo<br/><br/>python<br/><br/><div class="highlight"><pre><span class="k">def</span> <span class="nf">is_palindromic</span><span class="p">(</span><span class="n">number</span><span class="p">):</span><br/><span class="sd">'''return True if the number is a palindrome'''</span><br/><span class="n">number</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><br/><br/><span class="n">limit_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2</span><br/><br/><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">%</span> <span class="mf">2</span> <span class="o">==</span> <span class="mf">1</span><span class="p">:</span><br/><span class="n">limit_end</span> <span class="o">=</span> <span class="n">limit_start</span> <span class="o">+</span> <span class="mf">1</span><br/><span class="k">else</span><span class="p">:</span><br/><span class="n">limit_end</span> <span class="o">=</span> <span class="n">limit_start</span><br/><br/><span class="k">return</span> <span class="n">number</span><span class="p">[</span><span class="n">limit_start</span><span class="p">:]</span> <span class="o">==</span> <span class="n">number</span><span class="p">[:</span><span class="n">limit_end</span><span class="p">][::</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span><br/><br/><span class="k">def</span> <span class="nf">get_largest_palindrome</span><span class="p">():</span><br/><span class="sd">'''get the largest 3  digit palindrome'''</span><br/><span class="n">temp</span> <span class="o">=</span> <span class="mf">0</span><br/><br/><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">999</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1</span><span class="p">):</span><br/><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1</span><span class="p">):</span><br/><span class="n">value</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><br/><span class="k">if</span> <span class="n">is_palindromic</span><span class="p">(</span><span class="n">value</span><span class="p">):</span><br/><span class="k">if</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">:</span><br/><span class="n">temp</span> <span class="o">=</span> <span class="n">value</span><br/><br/><span class="k">return</span> <span class="n">temp</span><br/><br/><span class="k">print</span> <span class="n">get_largest_palindrome</span><span class="p">()</span><br/></pre></div><br/><br/><br/>lisp<br/><br/><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">is-palindrome</span> <span class="p">(</span><span class="nv">num</span><span class="p">)</span><br/><span class="p">(</span><span class="k">progn</span><br/><span class="p">(</span><span class="nb">setf</span> <span class="nv">str</span> <span class="p">(</span><span class="nb">format</span> <span class="no">nil</span> <span class="s">"~a"</span> <span class="nv">num</span><span class="p">))</span><br/><span class="p">(</span><span class="nb">setf</span> <span class="nv">size</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">str</span><span class="p">))</span><br/><span class="p">(</span><span class="nb">setf</span> <span class="nv">first-half</span> <span class="p">(</span><span class="nb">truncate</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">size</span> <span class="mi">2</span><span class="p">)))</span><br/><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">evenp</span> <span class="nv">size</span><span class="p">)</span><br/><span class="p">(</span><span class="nb">setf</span> <span class="nv">second-half</span> <span class="nv">first-half</span><span class="p">)</span><br/><span class="c1">; else</span><br/><span class="p">(</span><span class="nb">setf</span> <span class="nv">second-half</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">first-half</span> <span class="mi">1</span><span class="p">)))</span><br/><span class="p">(</span><span class="nb">equal</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">str</span> <span class="mi">0</span> <span class="nv">first-half</span><span class="p">)</span> <span class="p">(</span><span class="nb">reverse</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">str</span> <span class="nv">second-half</span> <span class="nv">size</span><span class="p">)))))</span><br/><br/><span class="p">(</span><span class="nb">defun</span> <span class="nv">get-largest-palindrome</span> <span class="p">()</span><br/><span class="p">(</span><span class="k">progn</span><br/><span class="p">(</span><span class="nb">setf</span> <span class="nv">temp</span> <span class="mi">0</span><span class="p">)</span><br/><span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">i</span> <span class="nv">from</span> <span class="mi">999</span> <span class="nv">downto</span> <span class="mi">0</span> <span class="nb">do</span><br/><span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">j</span> <span class="nv">from</span> <span class="nv">i</span> <span class="nv">downto</span> <span class="mi">0</span> <span class="nb">do</span><br/><span class="p">(</span><span class="k">progn</span><br/><span class="p">(</span><span class="k">setq</span> <span class="nv">value</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">))</span><br/><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">is-palindrome</span> <span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">value</span> <span class="nv">temp</span><span class="p">))</span><br/><span class="p">(</span><span class="k">setq</span> <span class="nv">temp</span> <span class="nv">value</span><span class="p">)))))</span><br/><span class="nv">temp</span><span class="p">))</span><br/><br/><span class="p">(</span><span class="nb">print</span> <span class="p">(</span><span class="nv">get-largest-palindrome</span><span class="p">))</span><br/></pre></div><br/><br/><br/>erlang<br/><br/><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">ej_004</span><span class="p">).</span><br/><span class="p">-</span><span class="ni">compile</span><span class="p">(</span><span class="n">export_all</span><span class="p">).</span><br/><span class="c">%-export([get_largest_palindrome/0]).</span><br/><br/><span class="nf">is_palindrome</span><span class="p">(</span><span class="nv">Number</span><span class="p">)</span> <span class="o">-&gt;</span><br/><span class="nv">String</span> <span class="o">=</span> <span class="nb">integer_to_list</span><span class="p">(</span><span class="nv">Number</span><span class="p">),</span><br/><span class="nv">Size</span> <span class="o">=</span> <span class="nn">string</span><span class="p">:</span><span class="n">len</span><span class="p">(</span><span class="nv">String</span><span class="p">),</span><br/><span class="nv">FirstHalf</span> <span class="o">=</span> <span class="nv">Size</span> <span class="ow">div</span>  <span class="mi">2</span><span class="p">,</span><br/><br/><span class="k">case</span> <span class="nv">Size</span> <span class="ow">rem</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">of</span><br/><span class="n">false</span> <span class="o">-&gt;</span> <span class="nv">SecondHalf</span> <span class="o">=</span> <span class="nv">FirstHalf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><br/><span class="n">true</span> <span class="o">-&gt;</span> <span class="nv">SecondHalf</span> <span class="o">=</span> <span class="nv">FirstHalf</span> <span class="o">+</span> <span class="mi">2</span><br/><span class="k">end</span><span class="p">,</span><br/><br/><span class="nv">FirstPart</span> <span class="o">=</span> <span class="nn">string</span><span class="p">:</span><span class="n">substr</span><span class="p">(</span><span class="nv">String</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">FirstHalf</span><span class="p">),</span><br/><span class="nv">SecondPart</span> <span class="o">=</span> <span class="nn">lists</span><span class="p">:</span><span class="n">reverse</span><span class="p">(</span><span class="nn">string</span><span class="p">:</span><span class="n">substr</span><span class="p">(</span><span class="nv">String</span><span class="p">,</span> <span class="nv">SecondHalf</span><span class="p">,</span> <span class="nv">Size</span><span class="p">)),</span><br/><br/><span class="nv">FirstPart</span> <span class="o">==</span> <span class="nv">SecondPart</span><span class="p">.</span><br/><br/><span class="nf">get_largest_palindrome</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Accum</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">Accum</span><span class="p">;</span><br/><span class="nf">get_largest_palindrome</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Accum</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">get_largest_palindrome</span><span class="p">(</span><span class="nv">X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">Accum</span><span class="p">);</span><br/><br/><span class="nf">get_largest_palindrome</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Accum</span><span class="p">)</span> <span class="o">-&gt;</span><br/><span class="nv">Value</span> <span class="o">=</span> <span class="nv">X</span> <span class="o">*</span> <span class="nv">Y</span><span class="p">,</span><br/><br/><span class="k">case</span> <span class="n">is_palindrome</span><span class="p">(</span><span class="nv">Value</span><span class="p">)</span> <span class="ow">andalso</span> <span class="nv">Value</span> <span class="o">&gt;</span> <span class="nv">Accum</span> <span class="k">of</span><br/><span class="n">true</span> <span class="o">-&gt;</span> <span class="nv">NewValue</span> <span class="o">=</span> <span class="nv">Value</span><span class="p">;</span><br/><span class="n">false</span> <span class="o">-&gt;</span> <span class="nv">NewValue</span> <span class="o">=</span> <span class="nv">Accum</span><br/><span class="k">end</span><span class="p">,</span><br/><br/><span class="n">get_largest_palindrome</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">NewValue</span><span class="p">).</span><br/><br/><span class="nf">get_largest_palindrome</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Accum</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">get_largest_palindrome</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Accum</span><span class="p">).</span><br/><span class="nf">get_largest_palindrome</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">get_largest_palindrome</span><span class="p">(</span><span class="mi">999</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><br/></pre></div>
<div style="clear: both;"/>
