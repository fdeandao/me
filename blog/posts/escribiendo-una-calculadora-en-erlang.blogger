
buscando una excusa para seguir aprendiendo erlang encontré una interesante, escribir algo así como un lenguaje de juguete paso a paso y ver para donde dispara (o donde lo abandono)<br/><br/>en una serie de posts (espero seguir escribiéndolos) voy a ir desde cero hasta un interprete interactivo que permita hacer cosas como estas (y mas)<br/><br/>&lt; a = 10 + (2 * 3) # calculo totalmente innecesario<br/>&gt; 16<br/>&lt; b = a * 2<br/>&gt; 32<br/>&lt; a<br/>&gt; 16<br/>&lt; b<br/>&gt; 32<br/>&lt; a == b or b &gt; a<br/>&gt; true<br/><br/><br/>este post es la patada de inicio asi que vamos a ver la herramientas.<br/><br/>Como lenguaje de programación obviamente vamos a usar erlang (que es lo que quiero aprender :D).<br/><br/>para el análisis léxico vamos a usar leex y para el análisis sintáctico y generación del árbol vamos a usar yecc.<br/><br/>para tener erlang hagan algo similar a:<br/><br/><span style="font-style: italic;">sudo aptitude install erlang<br/><br/></span>(adaptenlo a su distro)<br/><br/>yecc viene incluido en erlang así que andamos con suerte, a donde no andamos con suerte es con leex, que lo tendremos que bajar de aquí:<br/><br/><a href="http://forum.trapexit.org/download.php?id=184&amp;sid=9eba63c4011e517629e8d5a73e4e2ff5">http://forum.trapexit.org/download.php?id=184&amp;sid=9eba63c4011e517629e8d5a73e4e2ff5</a><br/><br/>pueden buscar si hay una versión mas nueva acá:<br/><br/><a href="http://forum.trapexit.org/viewtopic.php?p=43924#43924">http://forum.trapexit.org/viewtopic.php?p=43924#43924</a><br/><br/>lo bajan, descomprimen y ejecutan make en el directorio, luego para poder usarlo en erlang lo que hice (quizás no muy bueno pero anda :P) es crear un directorio llamado /usr/lib/erlang/lib/leex-0.3 y poner adentro leex.beam y el directorio include.<br/><br/>ahora con todo instalado vamos a largarnos con nuestro primer intento (remito a la documentación de cada uno para darse una mejor idea de que hacen y como se usan).<br/><br/>vamos a definir un lenguaje que nos permita sumar y restar números enteros<br/><br/>creemos un directorio llamado match-1-add-sub-ints<br/><br/>y adentro creamos un archivo llamado calc_lexer.xrl con el siguiente contenido<br/><br/><pre><br/>Definitions.<br/><br/>D   = [0-9]<br/>AOP   = (\+|-)<br/>WS  = ([\000-\s]|#.*)<br/><br/>Rules.<br/><br/>{AOP}   : {token,{add_operator,TokenLine,list_to_atom(TokenChars)}}.<br/>{D}+   : {token,{integer,TokenLine,list_to_integer(TokenChars)}}.<br/>{WS}+  : skip_token.<br/><br/>Erlang code.<br/><br/></pre><br/><br/>este archivo lo que hace es separar un string en partes (o tokens) que identifican distintos componentes de nuestro lenguaje. En el caso de un lenguaje para sumar números enteros lo que queremos dividir son los números, los signos + y - y descartar los espacios (y también todo lo que venga después de # ya que son comentarios)<br/><br/>en la sección de definiciones definimos las distintas expresiones regulares.<br/><br/>definimos una expresión regular para números enteros<br/><br/>D   = [0-9]<br/><br/>una para los signos + y -<br/><br/>AOP   = (\+|-)<br/><br/>y una para los blancos y los comentarios<br/><br/>WS  = ([\000-\s]|#.*)<br/><br/>luego en la sección Rules. definimos que debe generar (la parte de la derecha) cuando se encuentre con las expresiones de la izquierda.<br/><br/>si se encuentra con un signo + o - que genere una tupla que dice que es un operador de suma, que ponga la posición en donde encontró el token y que convierta lo que matchea la expresión a un atomo.<br/><br/>{AOP}   : {token,{add_operator,TokenLine,list_to_atom(TokenChars)}}.<br/><br/>si se encuentra con uno o mas dígitos que genere una tupla que dice que es un entero, la posición del token y el numero entero que encontró.<br/><br/>{D}+   : {token,{integer,TokenLine,list_to_integer(TokenChars)}}.<br/><br/>si encuentra blancos que los salte.<br/><br/>{WS}+  : skip_token.<br/><br/>ahora ya podemos dividir el texto de entrada en pedazos mas manejables gracias a leex, ahora vamos a ver como salio esto. Iniciamos un interprete de erlang y le decimos a leex que genere un modulo de erlang para manejar los tokens que definimos, luego compilamos el modulo generado y lo probamos con un string valido<br/><br/><pre><br/>$  erl<br/>Erlang (BEAM) emulator version 5.6.5 [source] [async-threads:0] [kernel-poll:false]<br/><br/>Eshell V5.6.5  (abort with ^G)<br/>1&gt; leex:file(calc_lexer).<br/>{ok,"calc_lexer.erl"}<br/>2&gt; c(calc_lexer).<br/>{ok,calc_lexer}<br/>3&gt; {ok, Tokens, _Endline} = calc_lexer:string("1 + 2 - 3 # esto es un comentario").<br/>{ok,[{integer,1,1},<br/>     {add_operator,1,'+'},<br/>     {integer,1,2},<br/>     {add_operator,1,'-'},<br/>     {integer,1,3}],<br/>    1} <br/></pre><br/><br/>como vemos nos devolvió una estructura de datos con las partes que definimos.<br/><br/>ahora vamos a definir un modulo para poder hacer algo con ese árbol que definimos.<br/><br/>creamos un archivo que se llame calc_parser.yrl con el siguiente contenido:<br/><br/><pre><br/>Nonterminals<br/>predicate.<br/><br/>Terminals<br/>add_operator integer.<br/><br/>Rootsymbol predicate.<br/><br/>Left 300 add_operator.<br/><br/>predicate -&gt; predicate add_operator predicate : {unwrap('$2'), '$1', '$3'}.<br/><br/>predicate -&gt; integer : unwrap('$1').<br/><br/>Erlang code.<br/><br/>unwrap({_,_,V}) -&gt; V.<br/><br/></pre><br/><br/>este documento define los nodos no terminales, los nodos terminales el símbolo raíz, la asociatividad de los operandos y luego define la sintaxis (para mas datos sobre las primeras secciones leer la documentación en linea de <a href="http://www.erlang.org/doc/man/yecc.html">yecc</a> o algun libro sobre lenguajes, otra opción es ponerse a romper esto y aprender :D).<br/><br/>la parte mas interesante es la que define que un predicado puede estar compuesto por la suma de dos predicados:<br/><br/>predicate -&gt; predicate add_operator predicate : {unwrap('$2'), '$1', '$3'}.<br/><br/>o puede ser solo un entero<br/><br/>predicate -&gt; integer : unwrap('$1').<br/><br/>lo que esta después de los dos puntos es el código erlang ejecutado cuando esa expresión es encontrada. Lo que hacemos es generar otra estructura de datos que vamos a manipular en erlang.<br/><br/>luego tenemos una función de utilidad en erlang para sacar un valor de interés de una tupla.<br/><br/>ahora generamos el modulo erlang que va a parsear la salida de leex y convertirla en otra estructura:<br/><br/><pre><br/>$  erl<br/>Erlang (BEAM) emulator version 5.6.5 [source] [async-threads:0] [kernel-poll:false]<br/><br/>Eshell V5.6.5  (abort with ^G)<br/>1&gt; yecc:file(calc_parser).<br/>{ok,"calc_parser.erl"}<br/>2&gt; c(calc_parser).<br/>{ok,calc_parser}<br/>3&gt; {ok, Tokens, _Endline} = calc_lexer:string("1 + 2 - 3").<br/>{ok,[{integer,1,1},<br/>     {add_operator,1,'+'},<br/>     {integer,1,2},<br/>     {add_operator,1,'-'},<br/>     {integer,1,3}],<br/>    1}<br/>4&gt; {ok, Tree} = calc_parser:parse(Tokens)                                                       <br/>4&gt; .<br/>{ok,{'-',{'+',1,2},3}}<br/></pre><br/><br/>para los curiosos, si se fijan el resultado que nos dio es muy parecido a una expresión de lisp :)<br/><br/>{'-',{'+',1,2},3}<br/><br/><pre><br/>[1]&gt; (- (+ 1 2) 3)<br/>0<br/></pre><br/><br/>bueno, ahora tenemos algo que se parece mucho a lisp, podríamos escribir lisp! pero no :D vamos a interpretarlo con un programa de erlang.<br/><br/>creen un archivo calc.erl que contenga lo siguiente:<br/><br/><pre><br/>-module(calc).<br/>-export([solve/1]).<br/><br/>solve(String) -&gt;<br/>    {ok, Tokens, _Endline} = calc_lexer:string(String),<br/>    {ok, Tree} = calc_parser:parse(Tokens),<br/>    matches(Tree).<br/><br/>matches(A) when is_integer(A) -&gt; A;<br/>matches({'+', A, B}) -&gt; matches(A) + matches(B);<br/>matches({'-', A, B}) -&gt; matches(A) - matches(B);<br/>matches(_) -&gt; error.<br/></pre><br/><br/>lo que hace este modulo es definir una función que recibe un string por parámetro con el calculo que queremos realizar, lo pasar por el analizador lexicografico, le da la salida de este como entrada al parser y con el árbol sintáctico resultante llama a la función matches que gracias al pattern matching se encarga de ejecutar recursivamente la instrucción correcta y devolver el resultado final (o un error en caso de que algo no matchee).<br/><br/>ahora vamos a compilar esto y probarlo un poco:<br/><br/><pre><br/>$  erl<br/>Erlang (BEAM) emulator version 5.6.5 [source] [async-threads:0] [kernel-poll:false]<br/><br/>Eshell V5.6.5  (abort with ^G)<br/>1&gt; c(calc).<br/>{ok,calc}<br/>2&gt; calc:solve("1 + 2 - 3 # deberia dar 0").<br/>0<br/>3&gt; calc:solve("1 + 2 - 3 - 4").            <br/>-4<br/></pre><br/><br/>bueno, ya tenemos la primera versión de nuestra calculadora, en la próxima vamos a agregar soporte para números de punto flotante con algunos leves cambios.<br/><br/>para los fiacosos como yo, el codigo de este ejemplo (y de los subsiguientes) esta en github aca:<br/><br/><a href="http://github.com/marianoguerra/match">http://github.com/marianoguerra/match</a>
<div style="clear: both;"/>
