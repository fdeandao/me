
aclaro que los quotes que pongo sobre programacion son solo eso, quotes, no quiere decir que este 100% de acuerdo con todos, pero que si los pongo es porque al menos me hicieron reir.<br/><br/><span class="epigraph">  <p> <i>C combines all the power of assembly language with all the ease of use of assembly language. </i> </p><p>     -- unknown </p><p> <i>I'd just like to take this moment to point out that C has all the expressive power of two dixie cups and a string.</i> </p><p>      -- Jamie Zawinski, in the source code for xkeycaps  </p><p>  <i>There is a point in your life when you realize that you have written enough destructors, and have spent enough time tracking down a memory leak, and you have spend enough time tracking down memory corruption, and you have spent enough time using low-level insecure functions, and you have implemented way too many linked lists.</i>  </p><p>      -- Miguel de Icaza  </p><p> <i>Greenspun's Tenth Rule of Programming: "Any sufficiently complicated C or      Fortran program contains an ad-hoc, informally-specified bug-ridden      slow implementation of half of Common Lisp."</i> </p><p>     -- Philip Greenspun   </p><p> <i>Your superior intellect is no match for our puny weapons.</i> </p><p>     -- unknown, via Aaron Stern<br/></p><p><br/></p></span><h3>C++</h3>     <span class="epigraph">  <p> <i>C++ : an octopus made by nailing extra legs onto a dog.  </i> </p><p>     -- off smalltalk.org  </p><p> <i>Think of C++ as an object-oriented assembly language.</i> </p><p>     -- off the guile Scheme mailing list  </p><p> <i>C makes it easy to shoot yourself in the foot.  C++ makes it harder, but when you do, you blow your whole leg off. </i> </p><p>     -- Bjarne Stroustrup  </p><p> <i>Programming in C++ is premature optimization. </i> </p><p>     -- off comp.lang.python<br/></p><p>The abstraction level of both C# and Java is mediocre; it's much better than C, somewhat weaker (!) than C++, and not nearly as good as languages that support both object-oriented and functional programming (such as Lisp and Ocaml).  Therefore, I find programming in these languages to be pretty boring and tedious.  Many of the scalability features in these languages are not, strictly speaking, part of the languages at all but of the environment(s) built up around the languages.  For instance, the support for components, versioning, packaging and documentation generation are all features of the environments.  I hope we will soon start to see these kinds of meta-features in better languages than Java or C#.<br/></p><p><span class="epigraph">  <p> <i>Python: executable pseudocode.  Perl: executable line noise.</i> </p><p>     -- off comp.lang.python<br/></p></span></p></span><h3>Common Lisp and Scheme</h3>     <span class="epigraph"> <p> <i>Most people are just too damn dumb to recognise how great Lisp is.</i> </p><p>     -- off slashdot </p><p> <i>[Lisp] is the only computer language that is beautiful.</i> </p><p>     -- Neal Stephenson </p><p> <i>The journey of a thousand miles begins with an open parenthesis.</i> </p><p>     -- Rainer Joswig </p><p> <i>Will write code that writes code that writes code for food.</i> </p><p>     -- Martin Rodgers </p><p> <i>Those who do not understand lisp are doomed to re-implement it.</i> </p><p>     -- attributed to Erik Naggum, off comp.lang.lisp<br/></p><p><br/></p><p>One of the consequences of all these features is that it is extremely easy to implement new programming paradigms within the Lisp language.  For instance, you can implement a full object-oriented system (or several different incompatible OO systems) within the Lisp language itself.  For this reason, Lisp is sometimes referred to as a "language laboratory".  Because of this, Lisp programmers often write their programs bottom-up by effectively writing a new program-specific language for the application and then writing the application in that language.  Paul Graham's book <a href="http://www.paulgraham.com/onlisp.html">On Lisp</a> discusses this approach in great detail.  Lisp is also an incredibly dynamic and flexible language; code can be compiled on the fly and modules can be re-loaded as needed.  Despite this, Lisp compilers exist that are very efficient and can routinely produce code that is only (say) 1.5 times slower than optimized C code.<br/></p><p><br/></p><p>todos sacados de aca:</p><p>http://www.cs.caltech.edu/~mvanier/hacking/rants/scalable_computer_programming_languages.html</p><p><br/></p><p>nota mental, leerlo de nuevo mas lento :P<br/></p></span><span class="epigraph"><p><span class="epigraph"/></p></span><span class="epigraph"/>
<div style="clear: both;"/>
