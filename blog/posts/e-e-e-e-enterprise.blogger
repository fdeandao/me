
<ul><li>Estas parseando metadatos de imagenes en tu super enterprise entorno java</li><li>le tiras un XPath al Nodo de los metadatos que te devuelve la API y no te devuelve nada</li><li>pensas "debe estar mal la query XPath"</li><li>lo probas en un debugger de XPath y anda</li><li>le das mil vueltas y sigue sin andar</li><li>probas con DOM a mano (que es una API horrenda) y anda</li><li>pero te negas a hacerlo en DOM pelado</li><li>seguis probando</li><li>"no puede ser que la API esta mal" pensas</li><li>ya te rendis y le preguntas a google</li><li>"This class is not intended to be used for general XML processing. In particular, Element nodes created within the Image I/O API are not compatible with those created by Sun's standard implementation of the org.w3.dom API. In particular, the implementation is tuned for simple uses and may not perform well for intensive processing."</li><li>Intensive processing? no responde a los queries XPath, eso no es intensive, eso es mal implementado!</li><li>lo siguiente lo dijo mejor este vago que lo que podria escribir yo asi que lo cito</li></ul>"<span style="font-weight: bold;">I can understand that IIOMetadataNode may be a subset of what is</span><br/><span style="font-weight: bold;">possible in a org.w3.dom.Node, but that does not mean it should</span><br/><span style="font-weight: bold;">actually be wrong. Since javax.imageio.metadata.IIOMetadata.</span><br/><span style="font-weight: bold;">getAsTree() returns an org.w3.dom.Node, I believe that compliance</span><br/><span style="font-weight: bold;">with the contract for org.w3.dom.Node is required.</span><br/><br/>In the case of the JPEG 2000 metadata accessed using this method,<br/>I have observed Nodes of type Element with Values set, which is<br/>illegal.<br/><br/>If Element nodes are not going to have Text children in your model,<br/>then they should have Attribute children with the Attribute name<br/>being "value", and I don't think the JPEG 2000 metadata is doing<br/>that (unlike the standard metadata which does use Attributes).<br/><br/><span style="font-weight: bold;">Also, it is all very well to say that the IIOMetadataNode is not</span><br/><span style="font-weight: bold;">a "real" Node, but the point of choosing this methodology was so</span><br/><span style="font-weight: bold;">as to allow the use of "ordinary" style DOM accessors</span>, at least<br/>that is how I remember the decision in the JSR 015 Expert Group<br/>discussions. It is presumably the point of the existence of the<br/>getAsTree() method.<br/><br/><span style="font-weight: bold;">To that end, if an ordinary Transformer cannot render the structure</span><br/><span style="font-weight: bold;">returned by getAsTree() as XML without losing information, and if</span><br/><span style="font-weight: bold;">XPath cannot query it, then I would argue that the implementation</span><br/><span style="font-weight: bold;">of getAsTree() is broken, not just limited.</span><br/><br/>The "ability to store an Object reference within a node" is all<br/>very well in special circumstances, but should NOT in my opinion,<br/>be abused just to point to a scalar type, for example. This begs<br/>the question of what the behavior is supposed to be, or defined<br/>to be, for javax.imageio.metadata.IIOMetadata.getAsTree() in<br/>such circumstances. Not that I have looked into the detail of<br/>how this is implemented, just wondering theoretically how such<br/>an Object reference would be correctly used and under what use<br/>cases it is required."<br/><br/>http://forums.java.net/jive/thread.jspa?messageID=255691<br/><br/>y el problema es que esto ya me paso antes, en la api del widget para mostrar Rich Text en swing no hay forma en la api para obtener el offset del cursor contando el HTML que esta por detras, solo te da el offset del texto que esta en pantalla, por lo tanto hay muchas acciones que se re complican, buscando en los foros por esa epoca habia respuestas como "si, sabemos que esta mal pero no lo vamos a arreglar por X o por Y".<br/><br/>muy enterprise..<br/><br/>Edit 1:<br/><br/><ul><li>por que no puedo iterar sobre un NodeList en ese pseudo foreach que tienen? es un iterable despues de todo no?</li><li>porque Vector no tiene una api para hacer slicing?</li><li>porque Vector, LinkedList y ArrayList son implementaciones de List? no podrian esconder los detalles de implementacion al usuario y hacerles pensar que estan eligiendo mal cada vez que eligen uno por sobre el otro?</li><li>Porque Vector es thread safe y LinkedList y ArrayList no?</li><li>La version limitada de Node que me devuelve la metadata de la imagen no me deja hacer getElementByTagName, asi que no puedo hacer mas que iterar por todos los childs buscando el que me hace falta ya que por suerte en la implementacion se mueve de posicion.</li><li>size() length() getLength() getSize(), no se ponen de acuerdo en eso no?</li></ul>demasiado por hoy
<div style="clear: both;"/>
