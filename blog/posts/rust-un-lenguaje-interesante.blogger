
<div style="text-align: justify;">pocos lenguajes me llaman la atención rápido y en pocas palabras, de los que puedo enumerar que me llamaron la atención de una forma u otra son: erlang (por el manejo de inmutabilidad, concurrencia y tolerancia a fallos), limbo (por los channels), go (porque es limbo pero mas marketinero), haskell (porque es haskell, lazy evaluation, inferencia de tipos, funcional puro, currying y un largo etc.) y el mas nuevo en llamarme la atención es <a href="http://github.com/graydon/rust/">Rust</a>, un lenguaje bastante alpha desarrollado por mozilla.</div><div style="text-align: justify;"><br/></div><div style="text-align: justify;">del manual rescato algunas cosas que me parecieron interesantes.</div><div style="text-align: justify;"><br/></div><div style="text-align: justify;"><a href="http://cloud.github.com/downloads/graydon/rust/rust-2010-07-08-snap.pdf">http://cloud.github.com/downloads/graydon/rust/rust-2010-07-08-snap.pdf</a><br/><br/><i>No null pointers</i></div><div style="text-align: justify;"><i><br/>
The initialization state of every slot is statically computed as part of the typestate<br/>
system (see below), and requires that all slots are initialized before use. There is nonull value; uninitialized slots are uninitialized, and can only be written to, not read.</i><br/><br/>
si no esta inicializada te da error de compilacion, no podes leer de la variable si no la inicializaste. asi de simple :D<br/><br/><i>Lightweight tasks with no shared mutable state</i></div><div style="text-align: justify;"><i><br/>
Like many actor languages, Rust provides an isolation (and concurrency) model based on lightweight tasks scheduled by the language runtime. These tasks are very inexpensive and statically unable to mutate one another’s local memory. Breaking the rule of task isolation is only possible by calling external (C/C++) code.<br/>
Inter-task communication is typed, asynchronous and simplex, based on passing messages over channels to ports.</i><br/><br/>
te suena de otro lenguaje? ;)<br/><br/><i>State values can refer to non-state values, but not vice-versa. Rust therefore encourages the programmer to write in a style that consists primarily of immutable types, but also permits limited, local (per-task) mutability.<br/><br/>
Structural types may be pattern-matched in an alt statement.<br/><br/>
Rust provides a mechanism of partially binding arguments to functions, producing new functions that accept the remaining un-bound arguments. This mechanism combines some of the features of lexical closures with some of the features of currying, in a smaller and simpler package.<br/><br/>
Rust supports local type inference:</i></div><div style="text-align: justify;"><i><br/>
signatures of functions, objects and iterators always require type annotation, but within the body of a function or iterator many slots can be declared auto and Rust will infer the slot’s type from its uses.<br/><br/>
Rust has a lightweight object system based on structural object types: there is no “class hierarchy” nor any concept of inheritance. </i><br/><br/>
parecido a go...<br/><br/><i>Method overriding and object restriction are performed explicitly on object values, which are little more than order-insensitive records of methods sharing a common private value. <br/><br/>
Rust includes support for values of a top type, any, that can hold any type of value whatsoever. An any value is a pair of a type code and a boxed value of that type.<br/><br/>
Injection into an any and projection by type-case-selection is integrated into the language.<br/><br/>
Rust supports a system for syntactic extensions that can be loaded into the compiler, to implement user-defined notations, macros, program-generators and the like.<br/><br/>
Rust has a system for propagating task-failures and other spontaneous events between tasks. Some signals can be trapped and redirected to channels; other signals are fatal and result in task-failure. Tasks can designate other tasks to handle signals for them.<br/>
This permits organizing tasks into mutually-supervising or mutually-failing groups.</i><br/>
bastante erlangoso :P<br/><br/>
Dentro de las influencias nombra a Joe Armstrong</div><div style="text-align: justify;"/><div style="text-align: justify;"/><div style="text-align: justify;"/><div style="text-align: justify;"/><div style="text-align: justify;"/><div style="text-align: justify;"/><br/><br/><div style="text-align: justify;"><br/></div><div style="text-align: justify;">veremos para donde dispara este lenguaje, espero que le vaya bien. </div>
<div style="clear: both;"/>
