
Jugando un poco con decoradores y el modulo inspect por primera vez, se me ocurrió intentar reemplazar alguna funcionalidad de gobject.<br/><br/>La funcionalidad que implemente primero, que es bastante útil, es la de notificar a un objeto cuando un atributo de otro objeto cambia, por ejemplo, es útil para la lista de usuarios saber cuando el atributo "status" de un contacto cambia.<br/> Lo que quería, era que las clases "notificadoras" y las clases "notificables" no tuvieran tanto código feo de manejo de eventos, para eso, decidí ver si los decoradores eran la solución, parece ser que si.<br/><br/>ejemplo, una clase "TestObject" tiene un atributo llamado "attribute" con las properties de get/set.<br/>Eel código seria así:<br/><br/><pre><br/>class TestObject(object):<br/>    '''a class that have a property called attribute'''<br/><br/>    def __init__(self, attribute):<br/>        '''class contructor'''<br/>        self._attribute = attribute<br/><br/>    def set_attribute(self, attribute):<br/>        '''set the value of self._attribute'''<br/>        self._attribute = attribute<br/><br/>    def get_attribute(self):<br/>        '''return the value of attribute'''<br/>        return self._attribute<br/><br/>    attribute = property(fget=get_attribute, fset=set_attribute)<br/></pre><br/><br/>si, ya se que el property en ese caso es al pedo, pero va a ser requerido mas adelante, así que lo pongo :D.<br/><br/>ahora, una clase que desea ser notificada cuando el atributo "attribute" de la clase "TestObject" cambia.<br/>El código seria mas o menos así:<br/><br/><pre><br/>class TestNotificable(object):<br/>    '''a class that is notified when an attribute on other object changes'''<br/><br/>    def __init__(self):<br/>        '''class constructor'''<br/>        pass<br/><br/>    def on_property_changed(self, obj, attr_name, method_name, <br/>        old_value, new_value):<br/>            '''method called when an attribute is changed <br/>               on an object that we are attached to<br/>            '''<br/>            print("%s: %s changed in %s(%s).%s from %s to %s" % \<br/>                (str(id(self)), attr_name, obj.__class__.__name__, <br/>                    str(id(obj)), method_name, repr(old_value), <br/>                    repr(new_value)))<br/><br/></pre><br/><br/>no hay mucha magia, solo lo que necesitamos, un atributo y un método el cual es llamado cuando este atributo cambia<br/><br/>imaginen que haciendo:<br/><br/><pre><br/>obj = TestObject(5)<br/>notificable = TestNotificable()<br/>obj.attach(notificable)<br/>obj.attribute = 10<br/></pre><br/><br/>la salida fuera:<br/><br/><pre><br/>3084746540: attribute changed in TestObject(3084722988).set_attribute from 5 to 10<br/></pre><br/><br/>estaría bueno, pero cuantas lineas habría que agregar a cada clase para eso?<br/>si mis cálculos no fallan, 2 lineas a TestObject y ninguna a TestNotificable.<br/><br/>el código de las clases seria:<br/><br/><pre><br/>import signals<br/><br/><strong>class TestNotificable(signals.Notificable):</strong><br/>    '''a class that implements the notificable interface'''<br/><br/>    def __init__(self):<br/>        '''class constructor'''<br/>        pass<br/><br/>    def on_property_changed(self, obj, attr_name, method_name, <br/>        old_value, new_value):<br/>            '''method called when a method with the<br/>            @notify_change decorator from a signal.Object is called<br/>            '''<br/>            print "%s: %s changed in %s(%s).%s from %s to %s" % \<br/>                (str(id(self)), attr_name, obj.__class__.__name__, <br/>                    str(id(obj)), method_name, repr(old_value), <br/>                    repr(new_value))<br/><br/><strong>class TestObject(signals.Object):</strong><br/>    '''a class that have a property that notify when it's changed'''<br/><br/>    def __init__(self, attribute):<br/>        '''class contructor'''<br/><strong>signals.Object.__init__(self)</strong>        <br/>        self._attribute = attribute<br/><br/><strong>@signals.notify_change</strong><br/>    def set_attribute(self, attribute):<br/>        '''set the value of self._attribute'''<br/>        self._attribute = attribute<br/><br/>    def get_attribute(self):<br/>        '''return the value of attribute'''<br/>        return self._attribute<br/><br/>    attribute = property(fget=get_attribute, fset=set_attribute)<br/></pre><br/><br/>una función para probar el ejemplo:<br/><br/><pre><br/>def test():<br/>    '''test the implementation of signals'''<br/>    obj = TestObject(5)<br/><br/>    notificable = TestNotificable()<br/>    obj.attach(notificable)<br/><br/>    obj.attribute = 10<br/><br/>    notificable1 = TestNotificable()<br/>    obj.attach(notificable1)<br/><br/>    print("")<br/>    obj.attribute = None<br/>    print("")<br/><br/>    notificable2 = TestNotificable()<br/>    obj.attach(notificable2)<br/><br/>    try:<br/>        obj.attach("")<br/>        print("[EE] doesn't catch not notificables being attached")<br/>    except TypeError:<br/>        print("catch not notificables being attached")<br/><br/>    notificable = None<br/><br/>    if len(obj.notificables) == 2:<br/>        print("clean the list if a reference is removed")<br/>    else:<br/>        print("[EE] doesn't clean the list if a reference is removed")<br/><br/>    print("")<br/>    obj.attribute = True<br/><br/>    obj.deattach(notificable2)<br/>    print("\nshould show 1 notification\n")<br/>    obj.attribute = []<br/><br/>    notificable1 = None<br/><br/>    if len(obj.notificables) == 0:<br/>        print("clean the list if a reference is removed")<br/>    else:<br/>        print("[EE] doesn't clean the list if a reference is removed")<br/><br/>    obj.attribute = "shouldn't be shown"<br/><br/>if __name__ == '__main__':<br/>    test()<br/></pre><br/><br/>que produce la salida:<br/><br/><pre><br/>3083871212: attribute changed in TestObject(3083871244).set_attribute from 5 to 10<br/><br/>3083871212: attribute changed in TestObject(3083871244).set_attribute from 10 to None<br/>3083221740: attribute changed in TestObject(3083871244).set_attribute from 10 to None<br/><br/>catch not notificables being attached<br/>clean the list if a reference is removed<br/><br/>3083221740: attribute changed in TestObject(3083871244).set_attribute from None to True<br/>3083222572: attribute changed in TestObject(3083871244).set_attribute from None to True<br/><br/>should show 1 notification<br/><br/>3083221740: attribute changed in TestObject(3083871244).set_attribute from True to []<br/>clean the list if a reference is removed<br/></pre><br/><br/>el código de signals.py es el siguiente:<br/><br/><pre><br/>import weakref<br/>import inspect<br/><br/>'''a module that implement classes and methods to do signals on a pythonic<br/>way<br/>'''<br/><br/>class Object(object):<br/>    '''a class that represent an object that can call other objects<br/>    to notify about a changed property, must be used with the <br/>    @notify_change decorator, the classes that want to register<br/>    to receive notifications over property changes must inherit from<br/>    the Notificable interface<br/>    '''<br/><br/>    def __init__(self):<br/>        '''class constructor'''<br/>        # a list of weakrefs<br/>        self.notificables = []<br/><br/>    def notify_property_change(self, attr_name, method_name, <br/>        old_value, new_value):<br/>        '''call the on_property_changed of all the objects on the list<br/>        '''<br/>        # uncomment the code below to have a nice debug of the changes<br/>        # made to the properties on the objects that inherit from this<br/>        # class<br/>        #print("%s: %s changed in %s(%s).%s from %s to %s" % \<br/>        #    (str(id(self)), attr_name, obj.__class__.__name__, <br/>        #        str(id(obj)), method_name, repr(old_value), <br/>        #        repr(new_value)))<br/><br/>        for notificable in self.notificables:<br/>            notificable.on_property_changed(self, attr_name, method_name,<br/>                old_value, new_value)<br/><br/>    def attach(self, notificable):<br/>        '''attach an object that implement the Notificable interface,<br/>        add a weakref so it's deleted when the other reference to the<br/>        object are 0<br/>        '''<br/><br/>        if Notificable not in notificable.__class__.mro():<br/>            raise TypeError("the object must implement Notificable")<br/><br/>        self.notificables.append(weakref.proxy(notificable, <br/>            self.__clean_refs))<br/><br/>    def deattach(self, notificable):<br/>        '''remove the notificable obect from the list, if it exists'''<br/>        proxy = weakref.proxy(notificable)<br/><br/>        if proxy in self.notificables:<br/>            self.notificables.remove(proxy)<br/><br/>    def __clean_refs(self, reference):<br/>        '''remove the reference from the list, since it's going to be<br/>        cleaned by the garbage collector<br/>        '''<br/><br/>        self.notificables.remove(reference)<br/><br/>class Notificable(object):<br/>    '''Interface that define the methods to be implemented to be able<br/>    to register to an signals.Object to receive notifications when<br/>    a method with the @notify_change decorator is called<br/>    '''<br/><br/>    def on_property_changed(self, obj, attr_name, method_name, <br/>        old_value, new_value):<br/>            '''method called when a method with the<br/>            @notify_change decorator from a signal.Object is called<br/>            '''<br/>            pass<br/><br/>def notify_change(method):<br/>    '''decorator that add the ability to a setter/fset property to<br/>    notify other objects when an attribute of the object is modified<br/>    '''<br/><br/>    def new_method(*args):<br/>        '''the function that decorates the class method, basically it<br/>        run the setter and then try to notify the objects about the<br/>        change, the setter is runned first since it may raise an<br/>        exception, and we dont want to notify over a change that <br/>        wasn't made<br/>        '''<br/><br/>        arguments = inspect.getargspec(method)[0]<br/><br/>        if Object not in args[0].__class__.mro():<br/>            raise TypeError("object doesn't inherit from signals.Object")<br/><br/>        if len(arguments) != 2:<br/>            raise ValueError("method should receive two arguments")<br/><br/>        self_object = args[0]<br/>        name = arguments[1]<br/>        method_name = method.__name__<br/>        old_value = getattr(self_object, name)<br/>        new_value = args[1]<br/><br/>        return_value = method(*args)<br/>        self_object.notify_property_change(name, method_name, <br/>            old_value, new_value)<br/><br/>        return return_value<br/><br/>    return new_method<br/><br/></pre>
<div style="clear: both;"/>
