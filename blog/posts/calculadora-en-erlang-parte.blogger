
como la otra vez voy a marcar las diferencias<br/><br/>calc_lexer.xrl:<br/><br/><br/><span style="font-family: courier new;">Definitions.</span><br/><br/><span style="font-family: courier new;">D   = [0-9]</span><br/><span style="font-family: courier new;">AOP   = (\+|-)</span><br/><span style="font-family: courier new; font-weight: bold;">MOP   = (\*|/|%)</span><br/><span style="font-family: courier new;">WS  = ([\000-\s]|#.*)</span><br/><br/><span style="font-family: courier new;">Rules.</span><br/><br/><span style="font-family: courier new;">{AOP}   : {token,{add_operator,TokenLine,list_to_atom(TokenChars)}}.</span><br/><span style="font-family: courier new; font-weight: bold;">{MOP}   : {token,{mul_operator,TokenLine,list_to_atom(TokenChars)}}.</span><br/><span style="font-family: courier new;">{D}+   : {token,{integer,TokenLine,list_to_integer(TokenChars)}}.</span><br/><span style="font-family: courier new;">{D}+\.{D}+   : {token,{float,TokenLine,list_to_float(TokenChars)}}.</span><br/><span style="font-family: courier new;">{WS}+  : skip_token.</span><br/><br/><span style="font-family: courier new;">Erlang code.</span><br/><br/>----------------------------------------<br/><br/>nada del otro mundo, hacemos lo mismo que con los signos de adicion pero cambiando la expresion regular y el identificador.<br/><br/>ahora el parser:<br/><br/>calc_parser.yrl<br/><br/><span style="font-family: courier new;">Nonterminals </span><br/><span style="font-family: courier new;">predicate.</span><br/><br/><span style="font-family: courier new;">Terminals </span><br/><span style="font-family: courier new;">add_operator <span style="font-weight: bold;">mul_operator</span> integer float.</span><br/><br/><span style="font-family: courier new;">Rootsymbol predicate.</span><br/><br/><span style="font-family: courier new;">Left 300 add_operator.</span><br/><span style="font-family: courier new; font-weight: bold;">Left 400 mul_operator.</span><br/><br/><span style="font-family: courier new;">predicate -&gt; predicate add_operator predicate : {unwrap('$2'), '$1', '$3'}.</span><br/><span style="font-family: courier new; font-weight: bold;">predicate -&gt; predicate mul_operator predicate : {unwrap('$2'), '$1', '$3'}.</span><br/><br/><span style="font-family: courier new;">predicate -&gt; integer : unwrap('$1').</span><br/><span style="font-family: courier new;">predicate -&gt; float : unwrap('$1').</span><br/><br/><span style="font-family: courier new;">Erlang code.</span><br/><br/><span style="font-family: courier new;">unwrap({_,_,V}) -&gt; V.</span><br/><br/>----------------------------------<br/><br/>de nuevo, agregamos el identificador del nuevo simbolo no terminal, especificamos la asociatividad de la nueva operacion (tiene precedencia sobre la adicion). Y agregamos la regla para que lo transforme en una estructura de datos.<br/><br/>por ultimo la calculadora en si<br/><br/>calc.erl<br/><br/><span style="font-family: courier new;">-module(calc).</span><br/><span style="font-family: courier new;">-export([solve/1]).</span><br/><br/><span style="font-family: courier new;">solve(String) -&gt;</span><br/><span style="font-family: courier new;">    {ok, Tokens, _Endline} = calc_lexer:string(String),</span><br/><span style="font-family: courier new;">    {ok, Tree} = calc_parser:parse(Tokens),</span><br/><span style="font-family: courier new;">    matches(Tree).</span><br/><br/><span style="font-family: courier new;">matches(A) when is_number(A) -&gt; A;</span><br/><span style="font-family: courier new;">matches({'+', A, B}) -&gt; matches(A) + matches(B);</span><br/><span style="font-family: courier new;">matches({'-', A, B}) -&gt; matches(A) - matches(B);</span><br/><span style="font-family: courier new; font-weight: bold;">matches({'*', A, B}) -&gt; matches(A) * matches(B);</span><br/><span style="font-family: courier new; font-weight: bold;">matches({'/', A, B}) -&gt; matches(A) / matches(B);</span><br/><span style="font-family: courier new; font-weight: bold;">matches({'%', A, B}) -&gt; matches(A) rem matches(B);</span><br/><span style="font-family: courier new;">matches(_) -&gt; error.</span><br/><br/>----------------------------------------------<br/><br/>agregamos el matching de las nuevas operaciones.<br/><br/>para probar un poco el codigo de build_calc:test()<br/><br/><pre><br/>test() -&gt;<br/>    0 = calc:solve("1 + 2 - 3"),<br/>    6 = calc:solve("1 + 2 + 3"),<br/>    -4 = calc:solve("1 - 2 - 3"),<br/>    0.0 = calc:solve("1.0 + 2 - 3"),<br/>    6.0 = calc:solve("1 + 2.0 + 3"),<br/>    -4.0 = calc:solve("1 - 2.0 - 3"),<br/>    3.1 = calc:solve("1.0 + 2.1"),<br/>    7 = calc:solve("1 + 2 * 3"),<br/>    10 = calc:solve("2 * 3 + 4"),<br/>    7.1 = calc:solve("1.1 + 2 * 3"),<br/>    10.2 = calc:solve("2 * 3.1 + 4"),<br/>    1 = calc:solve("11 % 2"),<br/>    2 = calc:solve("1 + 11 % 2"),<br/>    11 = calc:solve("11 % 2 + 10"),<br/>    ok.<br/></pre><br/><br/>y por ultimo lo probamos<br/><br/><br/><pre><br/>$  erl<br/>Erlang (BEAM) emulator version 5.6.5 [source] [async-threads:0] [kernel-poll:false]<br/><br/>Eshell V5.6.5  (abort with ^G)<br/>1&gt; c(build_calc).<br/>{ok,build_calc}<br/>2&gt; build_calc:build().<br/>Old inliner: threshold=0 functions=[{yeccpars2_7_,1},<br/>                                    {yeccpars2_6_,1},<br/>                                    {yeccpars2_3_,1},<br/>                                    {yeccpars2_2_,1},<br/>                                    {yeccpars2_7_,1},<br/>                                    {yeccpars2_6_,1},<br/>                                    {yeccpars2_3_,1},<br/>                                    {yeccpars2_2_,1}]<br/>ok<br/>3&gt; rl(calc).<br/>ok<br/>4&gt; rl(calc_parser).<br/>ok<br/>5&gt; rl(calc_lexer). <br/>ok<br/>6&gt; build_calc:test().<br/>ok<br/></pre><br/><br/>en la proxima agregamos expresiones anidadas (parentesis)
<div style="clear: both;"/>
