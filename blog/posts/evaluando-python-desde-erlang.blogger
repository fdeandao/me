
y el secreto se develo, como tener algo como eval de python pero corriendolo desde erlang.<br/><br/>el codigo no es lo mas bonito de la tierra pero ya va a ir mejorando.<br/><br/>primero que todo bajate erlang R13B04 para tener la ultima version de la API de NIF.<br/><br/>crea un archivo pynerl.c<br/><br/><div class="highlight"><pre><span class="cm">/* pynerl.c */</span><br/><span class="cp">#include &lt;stdio.h&gt;</span><br/><span class="cp">#include "erl_nif.h"</span><br/><span class="cp">#include &lt;Python.h&gt;</span><br/><br/><span class="cp">#define STR_SIZE 1024</span><br/><span class="kt">char</span> <span class="n">code</span><span class="p">[</span><span class="n">STR_SIZE</span><span class="p">];</span><br/><br/><span class="k">static</span> <span class="n">ERL_NIF_TERM</span> <span class="nf">pyeval</span><span class="p">(</span><span class="n">ErlNifEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="n">ERL_NIF_TERM</span> <span class="n">argv</span><span class="p">[])</span><br/><span class="p">{</span><br/><span class="n">Py_Initialize</span><span class="p">();</span><br/><br/><span class="k">if</span> <span class="p">(</span><span class="n">enif_get_string</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">code</span><span class="p">,</span> <span class="n">STR_SIZE</span><span class="p">,</span> <span class="n">ERL_NIF_LATIN1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><br/><span class="k">return</span> <span class="n">enif_make_string</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">"code too long"</span><span class="p">,</span> <span class="n">ERL_NIF_LATIN1</span><span class="p">);</span><br/><span class="p">}</span><br/><span class="k">else</span> <span class="p">{</span><br/><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="n">code</span><span class="p">);</span><br/><span class="p">}</span><br/><br/><span class="n">Py_Finalize</span><span class="p">();</span><br/><br/><span class="k">return</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><br/><span class="p">}</span><br/><span class="k">static</span> <span class="n">ErlNifFunc</span> <span class="n">nif_funcs</span><span class="p">[]</span> <span class="o">=</span><br/><span class="p">{</span><br/><span class="p">{</span><span class="s">"pyeval"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pyeval</span><span class="p">}</span><br/><span class="p">};</span><br/><br/><span class="n">ERL_NIF_INIT</span><span class="p">(</span><span class="n">pynerl</span><span class="p">,</span><span class="n">nif_funcs</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span><br/></pre></div><br/><br/>y uno llamado pynerl.erl<br/><br/><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">pynerl</span><span class="p">).</span><br/><span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">init</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span> <span class="n">pyeval</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span><br/><br/><span class="p">-</span><span class="ni">on_load</span><span class="p">(</span><span class="n">init</span><span class="o">/</span><span class="mi">0</span><span class="p">).</span><br/><br/><span class="nf">init</span><span class="p">()</span> <span class="o">-&gt;</span><br/><span class="nn">erlang</span><span class="p">:</span><span class="n">load_nif</span><span class="p">(</span><span class="s">"./pynerl"</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><br/><br/><span class="nf">pyeval</span><span class="p">(_</span><span class="nv">Str</span><span class="p">)</span> <span class="o">-&gt;</span><br/><span class="s">"NIF library not loaded"</span><span class="p">.</span><br/></pre></div><br/><br/>despues compila ambos:<br/><br/><pre><br/>gcc -fPIC -shared -o pynerl.so pynerl.c -I $ERL_INCLUDE -I/usr/include/python3.1/ -D_THREAD_SAFE -lpthread -ldl  -lutil -lpython3.1 -lm<br/>$ERLC pynerl.erl<br/></pre><br/><br/>en mi caso<br/><br/><pre><br/>$ echo $ERL_INCLUDE<br/>/home/mariano/Software/otp_src_R13B04/erts/emulator/beam<br/>$ echo $ERLC<br/>/home/mariano/Software/otp_src_R13B04/bin/erlc<br/></pre><br/><br/>despues de eso lo probamos<br/><br/><pre><br/>$ $ERL<br/>Erlang R13B04 (erts-5.7.5) [source] [rq:1] [async-threads:0] [kernel-poll:false]<br/><br/>Eshell V5.7.5  (abort with ^G)<br/>1&gt; pynerl:pyeval("print('hello python 3.1 from erlang!')").<br/>hello python 3.1 from erlang!<br/>                            "print('hello python 3.1 from erlang!')"<br/></pre><br/><br/>observaciones:<br/><br/>uso $ERL porque tengo dos versiones de erlang instalando, esa variable apunta al erlang mas nuevo que tengo compilado.<br/><br/>la primera linea de salida es la ejecucion de la linea, la segunda es el string que le pase como parametro, que es lo que devuelve por ahora pyeval, algun dia va a devolver el objeto que devolvio la evaluacion (mientras sea algo que pueda ser convertido a un tipo de erlang).
<div style="clear: both;"/>
